<!DOCTYPE html>
<html>
    <head>
        <style>
            * {font-family: Calibri}
            body {background:#333; }
            #container {width:80%;margin: 0 auto}
            .heroes {display:inline-block; vertical-align: top; box-sizing:border-box; padding:0 10px;}
            .hero, .item {display:inline-block; margin:5px; width:100px; height:50px; background-size: cover; background-position:center center; cursor: pointer}
            .item {width:85px; height:64px;}
            .items {display:inline-block; margin-left:100px}
            .hero:hover {filter: grayscale(50%);}
            .hero.disabled {filter: grayscale(100%);}
            .hero.found {position:relative; z-index:2; margin-left: -24px; margin-right:-14px; width:140px; height:90px; margin-bottom:-14px; margin-top:-24px;border:4px solid #ddd}
            .toggle, .generate, .remove {font-weight: bold; display:block; cursor: pointer; width:100%; margin:10px 0; background:#444; color:#fff; border:0; font-size:20px; padding:10px 12px; outline: none !important}
            .remove {float:right; width: auto;}
            .toggle:hover, .generate:hover {background:#555}
            .build {margin: 40px 0}
            .build>* {vertical-align: middle}
            .skills {display:block;}
            .level {display:inline-block; text-align:center; margin:0 5px; font-weight: bold; font-size:20px; color:#fff; background:#222}
            .skill {display:block; width:50px; height:50px; background-position: center center; background-color:#111; background-size: cover}
            #tip {padding: 40px; color:#777; text-align:center; font-weight: bold}
            #search {position: fixed; z-index: 3; bottom: 100px; text-shadow: 2px 2px 10px rgba(0,0,0,1); font-size: 48px; width:100%; text-align:center; left:0; display:none; color:#fff; font-weight: bold; text-transform: uppercase}
            #loader {text-align:center}
            .lds-ripple {display: inline-block;position: relative;width: 128px;height: 128px;}
            .lds-ripple div {position: absolute;border: 4px solid #fff;opacity: 1;border-radius: 50%;animation: lds-ripple 1s cubic-bezier(0, 0.2, 0.8, 1) infinite;}
            .lds-ripple div:nth-child(2) {animation-delay: -0.5s;}
            @keyframes lds-ripple {
                0% {top: 56px;left: 56px;width: 0;height: 0;opacity: 1;}
                100% {top: -1px;left: -1px;width: 116px;height: 116px;opacity: 0;}
            }
        </style>
        <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
        <title>Dota 2 Random Hero Build Generator</title>
    </head>
    <body>
        <div id="tip">To search the hero, start typing hero's name</div>
        <div id="container">
            <div id="loader">
                <div class="lds-ripple">
                    <div></div><div></div>
                </div>
            </div>
        </div>
        <div id="search"></div>
        <script>
            Array.prototype.shuffle = function () {
                for (let i = this.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this[i], this[j]] = [this[j], this[i]];
                }
                return this;
            };

            const HeroAttribute = Object.freeze({
                STRENGTH: "str",
                AGILITY: "agi",
                INTELIGENCE: "int"
            });

            class HeroPicker {
                constructor (heroes, items, abilities) {
                    this.heroes = heroes;
                    this.items = items;
                    this.abilities = abilities;
                    this.searchString = "";
                }

                getHeroImage (heroname) {
                    return `http://cdn.dota2.com/apps/dota2/images/heroes/${heroname}_full.png?v`;
                }

                getItemImage (itemkey) {
                    const item = this.items.find(item => item.key === itemkey);
                    return `http://cdn.dota2.com/apps/dota2/images/items/${item.img}`;
                }

                getSkillImage (skillkey) {
                    return `http://cdn.dota2.com/apps/dota2/images/abilities/${skillkey}_hp1.png?v`;
                }

                isItemBoots (itemkey) {
                    const item = this.items.find(item => item.key === itemkey);
                    return item
                        && item.components
                        && (
                            item.components.includes("boots")
                            || item.components.some(component => this.isItemBoots(component))
                        );
                }

                updateSearch (event, data) {
                    switch (event) {
                        case "remove":
                            if (this.searchString.length) {
                                this.searchString = this.searchString.substring(0, this.searchString.length - 1);
                            }
                            break;
                        case "clear":
                            this.searchString = "";
                            break;
                        default:
                            this.searchString = this.searchString + data.toString().toLowerCase();
                    }
                    $("#search").html(this.searchString);
                    $("#search").stop().fadeIn(0).fadeOut(2000);
                    $(".heroes .hero.found").each(function () {
                        $(this).removeClass("found");
                    })
                    if (this.searchString.length) {
                        this.heroes
                            .filter(hero => hero.dname.toLowerCase().includes(this.searchString))
                            .forEach(hero => {
                                $(`.heroes .hero#${hero.key}`).addClass("found");
                            });
                    }
                }

                toggleAttributeHeroes (attribute) {
                    this.heroes
                        .filter(hero => hero.pa === HeroAttribute[attribute])
                        .forEach(hero => {
                            this.toggleHero(hero.key);
                        });
                }

                toggleHero (heroname) {
                    const hero = this.heroes.find(hero => hero.key === heroname);
                    hero.isActive = !hero.isActive;
                    $(`.heroes .hero#${heroname}`).toggleClass("disabled");
                }

                getHeroSkills (heroname) {
                    return this.abilities.filter(ability => ability.key.startsWith(heroname) || ability.key.startsWith(heroname.replace("_","")));
                }

                isSkillUlti (skillkey) {
                    const skill = this.abilities.find(ability => ability.key === skillkey);
                    const heroSkills = this.getHeroSkills(skill.hurl);
                    const skillIndex = heroSkills.findIndex(ability => ability.key === skill.key);
                    return skillIndex === (heroSkills.length - 1) && heroSkills.length > 3;
                }

                canSkillBeLearned (skillkey, level, current) {
                    if ([
                        "troll_warlord_whirling_axes_melee",
                        "morphling_adaptive_strike_str",
                        "morphling_morph_str",
                        "dark_willow_bedlam"
                    ].includes(skillkey)) {
                        return false;
                    }
                    if (!this.isSkillUlti(skillkey)) {
                        const levelForUp = current * 2 + 1;
                        let maxLevel = 4;
                        if (skillkey.startsWith("invoker")) {
                            maxLevel = 7;
                        } 
                        return !(level < levelForUp || current === maxLevel);
                    } else {
                        let levelsForUlti = [6,12,18];
                        const maxLevel = 3;
                        if (skillkey.startsWith("meepo")) {
                            levelsForUlti = [3,10,17];
                        }
                        return !(level < levelsForUlti[current] || current === maxLevel);
                    }
                }

                getRandomNum (size) {
                    return Math.floor(Math.random() * size);
                }

                generateBuild () {
                    const activeHeroes = this.heroes.filter(hero => hero.isActive);
                    let randomNum = this.getRandomNum(activeHeroes.length);
                    const hero = activeHeroes[randomNum];
                    const allBootsItems = this.items.filter(item => this.isItemBoots(item.key));
                    randomNum = this.getRandomNum(allBootsItems.length);
                    const boots = allBootsItems[randomNum];
                    const otherItems = this.items
                        .filter(item => 
                            !this.isItemBoots(item.key)
                            && item.cost >= 2000
                            && ["rare","epic","artifact"].includes(item.qual)
                        )
                        .shuffle()
                        .slice(0, 5);
                    const skills = this.generateSkillBuild(hero.key); 
                    console.log(skills);
                    return { hero, items: [ boots, ...otherItems ], skills };
                }

                generateSkillBuild (heroname) {
                    const skills = this.getHeroSkills(heroname);
                    const currentLevels = {};
                    const build = [];
                    skills.forEach(skill => currentLevels[skill.key] = 0);
                    for (let level = 1; level <= 25; level++) {
                        const skillsCanBeLearned = skills.filter(skill => this.canSkillBeLearned(skill.key, level, currentLevels[skill.key]));
                        if (skillsCanBeLearned.length) {
                            const skill = skillsCanBeLearned[this.getRandomNum(skillsCanBeLearned.length)];
                            const skillIndex = skills.findIndex(ability => ability.key === skill.key);
                            build.push(skillIndex);
                            currentLevels[skill.key]++;
                        } else {
                            build.push(-1);
                        }
                    }
                    return build;
                }

                renderBuild (build) {
                    const heroContainer = $(`<div class="hero" title="${build.hero.dname}"></div>`).css({ backgroundImage: `url(${this.getHeroImage(build.hero.key)})` });
                    const itemsContainer = $(`<div class="items"></div>`);
                    const skillBuildContainer = $(`<div class="skills"></div>`);
                    build.items.forEach(item => {
                        const itemContainer = $(`<div class="item" title="${item.dname}"></div>`).css({ backgroundImage: `url(${this.getItemImage(item.key)})` });
                        itemsContainer.append(itemContainer);
                    })
                    const heroSkills = this.getHeroSkills(build.hero.key);
                    build.skills.forEach((skillIndex, level) => {
                        const skill = heroSkills[skillIndex];
                        const levelContainer = $(`<div class="level"><span>${level + 1}</span></div>`);
                        let skillContainer;
                        if (skill) {
                            skillContainer = $(`<div class="skill" title="${skill.dname}"></div>`).css({ backgroundImage: `url(${this.getSkillImage(skill.key)})` });
                        } else {
                            skillContainer = $(`<div class="skill"></div>`);
                        }
                        levelContainer.append(skillContainer);
                        skillBuildContainer.append(levelContainer);
                    });
                    const buildContainer = $(`<div class="build"></div>`);
                    $(buildContainer).append(`<button class="remove">REMOVE</button>`);
                    $(buildContainer).append(heroContainer);
                    $(buildContainer).append(itemsContainer);
                    $(buildContainer).append(skillBuildContainer);
                    $("#build").append(buildContainer);
                }

                renderHeroes () {
                    Object.keys(HeroAttribute).forEach(attrKey => {
                        const heroesContainer = $(`<div id="${HeroAttribute[attrKey]}" class="heroes"></div>`).css({ width: `${100 / Object.keys(HeroAttribute).length}%` });
                        const toggleButton = $(`<button class="toggle" id="${attrKey}">TOGGLE ${attrKey}</button>`)
                        heroesContainer.append(toggleButton);
                        this.heroes
                            .filter(hero => hero.pa === HeroAttribute[attrKey])
                            .forEach(hero => {
                                heroesContainer.append($(`<div class="hero" id="${hero.key}" title="${hero.dname}"></div>`).css({ backgroundImage: `url(${this.getHeroImage(hero.key)})` }))
                            });
                        $("#container").append(heroesContainer);
                    });
                }
            }

            let picker = null;

            $(document).ready(() => {
                $.ajax({
                    url: "https://www.dota2.com/jsfeed/heropediadata?feeds=itemdata,abilitydata,herodata",
                    type: "GET",
                    crossDomain: true,
                    dataType: "jsonp",
                    success: (data) => {
                        $("#container").html("");
                        $("#container").append(`<button class="generate">GENERATE BUILD</button><div id="build"></div>`);
                        picker = new HeroPicker(
                            Object.keys(data.herodata)
                                .map(key => ({
                                    ...data.herodata[key],
                                    key,
                                    isActive: true
                                }))
                                .sort((a, b) => a.dname.localeCompare(b.dname)),
                            Object.keys(data.itemdata).map(key => ({
                                ...data.itemdata[key],
                                key
                            })),
                            Object.keys(data.abilitydata).map(key => ({
                                ...data.abilitydata[key],
                                key,
                                hurl: data.abilitydata[key].hurl.toLowerCase()
                            }))
                        );
                        picker.renderHeroes();
                    }
                });
            });

            $(document)
                .on("click", ".heroes .hero", function () {
                    const heroname = $(this).attr("id");
                    picker.toggleHero(heroname);
                })
                .on("click", ".toggle", function () {
                    const attribute = $(this).attr("id");
                    picker.toggleAttributeHeroes(attribute);
                })
                .on("click", ".generate", function () {
                    const build = picker.generateBuild();
                    picker.renderBuild(build);
                })
                .on("click", ".remove", function () {
                    $(this).parent().remove();
                })
                .on("keydown", "body", function (e) {
                    const key = e.which;
                    if (key === 8) {
                        picker.updateSearch("remove");
                    } else if ((key >= 65 && key <= 90) || key === 32) {
                        e.preventDefault();
                        picker.updateSearch("add", String.fromCharCode(e.which));
                    }
                }).on("mousedown", "body", function (e) {
                    picker.updateSearch("clear");
                });
        </script>
    </body>
</html>