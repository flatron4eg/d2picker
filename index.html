<!DOCTYPE html>
<html>
    <head>
        <style>
            * {font-family: Calibri}
            body {background:#333; }
            #container {width:80%;margin: 0 auto}
            .heroes {display:inline-block; vertical-align: top; box-sizing:border-box; padding:0 10px;}
            .hero, .item {display:inline-block; margin:5px; width:100px; height:50px; background-size: cover; background-position:center center; cursor: pointer}
            .item {width:85px; height:64px;}
            .items {display:inline-block; margin-left:100px}
            .hero:hover {filter: grayscale(50%);}
            .hero.disabled {filter: grayscale(100%);}
            .hero.found {position:relative; z-index:2; margin-left: -24px; margin-right:-14px; width:140px; height:90px; margin-bottom:-14px; margin-top:-24px;border:4px solid #ddd}
            .toggle, .generate, .remove {font-weight: bold; display:block; cursor: pointer; width:100%; margin:10px 0; background:#444; color:#fff; border:0; font-size:20px; padding:10px 12px; outline: none !important}
            .remove {float:right; width: auto;}
            .toggle:hover, .generate:hover, .remove:hover {background:#555}
            .build {margin: 40px 0}
            .build>* {vertical-align: middle}
            .skills {display:block;}
            .level {display:inline-block; text-align:center; margin:0 5px; font-weight: bold; font-size:20px; color:#fff; background:#222}
            .skill {display:block; width:50px; height:50px; background-position: center center; background-color:#111; background-size: cover}
            #tip {padding: 40px; color:#777; text-align:center; font-weight: bold}
            #search {position: fixed; z-index: 3; bottom: 100px; text-shadow: 2px 2px 10px rgba(0,0,0,1); font-size: 48px; width:100%; text-align:center; left:0; display:none; color:#fff; font-weight: bold; text-transform: uppercase}
            #loader {text-align:center}
            .lds-ripple {display: inline-block;position: relative;width: 128px;height: 128px;}
            .lds-ripple div {position: absolute;border: 4px solid #fff;opacity: 1;border-radius: 50%;animation: lds-ripple 1s cubic-bezier(0, 0.2, 0.8, 1) infinite;}
            .lds-ripple div:nth-child(2) {animation-delay: -0.5s;}
            .image.loading {animation: breath 1s infinite; background:#fff}
            @keyframes lds-ripple {
                0% {top: 56px;left: 56px;width: 0;height: 0;opacity: 1;}
                100% {top: -1px;left: -1px;width: 116px;height: 116px;opacity: 0;}
            }
            @keyframes breath {
                0% {opacity:0.8}
                100% {opacity:0.2}
            }
        </style>
        <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
        <title>Dota 2 Random Hero Build Generator</title>
        <link rel="icon" type="image/x-icon" href="img/favicon.ico">
    </head>
    <body>
        <div id="tip">To search the hero, start typing hero's name</div>
        <div id="container">
            <div id="loader">
                <div class="lds-ripple">
                    <div></div><div></div>
                </div>
            </div>
        </div>
        <div id="search"></div>
        <script>
            Array.prototype.shuffle = function () {
                for (let i = this.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this[i], this[j]] = [this[j], this[i]];
                }
                return this;
            };

            const HeroAttribute = Object.freeze({
                STRENGTH: "str",
                AGILITY: "agi",
                INTELIGENCE: "int"
            });

            class HeroPicker {
                constructor (heroes, items, abilities) {
                    this.heroes = heroes;
                    this.items = items;
                    this.abilities = abilities;
                    this.searchString = "";
                    this.ignoredSkills = [
                        // doubled skills
                        "troll_warlord_whirling_axes_melee",
                        "morphling_adaptive_strike_str",
                        "morphling_morph_str",
                        "dark_willow_bedlam",
                        "ember_spirit_activate_fire_remnant",
                        "wisp_spirits_in",
                        "wisp_spirits_out",
                        // aghanim scepter skills
                        "clinkz_burning_army",
                        "rattletrap_overclocking",
                        "earth_spirit_petrify",
                        "enchantress_bunny_hop",
                        "grimstroke_dark_portrait",
                        "kunkka_torrent_storm",
                        "lycan_wolf_bite",
                        "nyx_assassin_burrow",
                        "ogre_magi_unrefined_fireblast",
                        "snapfire_gobble_up",
                        "spectre_haunt_single",
                        "templar_assassin_trap_teleport",
                        "shredder_chakram_2",
                        "tiny_tree_channel",
                        "treant_eyes_in_the_forest",
                        "tusk_walrus_kick",
                        "zuus_cloud",
                        "meepo_petrify",
                        // aghanim shard skills
                        "alchemist_berserk_potion",
                        "bristleback_hairball",
                        "broodmother_silken_bola",
                        "rattletrap_jetpack",
                        "dark_seer_normal_punch",
                        "dragon_knight_fireball",
                        "faceless_void_time_walk_reverse",
                        "grimstroke_ink_over",
                        "jakiro_liquid_ice",
                        "kunkka_tidal_wave",
                        "lich_ice_spire",
                        "life_stealer_open_wounds",
                        "magnataur_horn_toss",
                        "medusa_cold_blooded",
                        "necrolyte_death_seeker",
                        "ogre_magi_smash",
                        "omniknight_hammer_of_purity",
                        "pangolier_rollup",
                        "phantom_assassin_fan_of_knives",
                        "pudge_eject",
                        "riki_poison_dart",
                        "slark_fish_bait",
                        "sniper_concussive_grenade",
                        "storm_spirit_electric_rave",
                        "terrorblade_demon_zeal",
                        "shredder_flamethrower",
                        "tinker_defense_matrix",
                        "tiny_craggy_exterior",
                        "tusk_frozen_sigil",
                        "witch_doctor_voodoo_switcheroo",
                        // ???
                        "beastmaster_mark_of_the_beast",
                        // invoker spells
                        "invoker_cold_snap",
                        "invoker_ghost_walk",
                        "invoker_tornado",
                        "invoker_emp",
                        "invoker_alacrity",
                        "invoker_chaos_meteor",
                        "invoker_sun_strike",
                        "invoker_forge_spirit",
                        "invoker_ice_wall",
                        "invoker_deafening_blast",
                    ];
                    this.ignoredItems = [
                        "dagon",
                        "dagon_2",
                        "dagon_3",
                        "dagon_4"
                    ];
                    this.fixedSkillImage = {
                        riki_backstab: "riki_permanent_invisibility"
                    };
                }

                getHeroImage (heroname) {
                    return `http://cdn.dota2.com/apps/dota2/images/heroes/${heroname}_full.png?v`;
                }

                getItemImage (itemkey) {
                    const item = this.items.find(item => item.key === itemkey);
                    return `http://cdn.dota2.com/apps/dota2/images/items/${item.img}`;
                }

                getSkillImage (skillkey) {
                    if (this.isSkillTalent(skillkey)) {
                        return `img/${skillkey}.png`;
                    }
                    const imageKey = this.fixedSkillImage[skillkey] || skillkey;
                    return `http://cdn.dota2.com/apps/dota2/images/abilities/${imageKey}_hp1.png?v`;
                }

                isItemBoots (itemkey) {
                    const item = this.items.find(item => item.key === itemkey);
                    return item
                        && item.components
                        && (
                            item.components.includes("boots")
                            || item.components.some(component => this.isItemBoots(component))
                        );
                }

                updateSearch (event, data) {
                    switch (event) {
                        case "remove":
                            if (this.searchString.length) {
                                this.searchString = this.searchString.substring(0, this.searchString.length - 1);
                            }
                            break;
                        case "clear":
                            this.searchString = "";
                            break;
                        default:
                            this.searchString = this.searchString + data.toString().toLowerCase();
                    }
                    $("#search").html(this.searchString);
                    $("#search").stop().fadeIn(0).fadeOut(2000);
                    $(".heroes .hero.found").each(function () {
                        $(this).removeClass("found");
                    })
                    if (this.searchString.length) {
                        this.heroes
                            .filter(hero => hero.dname.toLowerCase().includes(this.searchString))
                            .forEach(hero => {
                                $(`.heroes .hero#${hero.key}`).addClass("found");
                            });
                    }
                }

                toggleAttributeHeroes (attribute) {
                    this.heroes
                        .filter(hero => hero.pa === HeroAttribute[attribute])
                        .forEach(hero => {
                            this.toggleHero(hero.key);
                        });
                }

                toggleHero (heroname) {
                    const hero = this.heroes.find(hero => hero.key === heroname);
                    hero.isActive = !hero.isActive;
                    $(`.heroes .hero#${heroname}`).toggleClass("disabled");
                }

                getHeroSkills (heroname) {
                    const skills = this.abilities.filter(ability => ability.key.startsWith(heroname) || ability.key.startsWith(heroname.replace("_","")));
                    const talents = [
                        { dname: "Talent Left", key: "talent_left", hurl: heroname },
                        { dname: "Talent Right", key: "talent_right", hurl: heroname }
                    ];
                    return [ ...talents, ...skills ];
                }

                isSkillUlti (skillkey) {
                    const skill = this.abilities.find(ability => ability.key === skillkey);
                    if (!skill) {
                        return false;
                    }
                    const heroSkills = this.getHeroSkills(skill.hurl);
                    const skillIndex = heroSkills.findIndex(ability => ability.key === skill.key);
                    return skillIndex === (heroSkills.length - 1) && heroSkills.length > 5;
                }

                isSkillTalent (skillkey) {
                    return skillkey.startsWith("talent");
                }

                canSkillBeLearned (skillkey, level, current) {
                    if (this.ignoredSkills.includes(skillkey)) {
                        return false;
                    }
                    let maxLevel;
                    let levelForUp;
                    if (this.isSkillUlti(skillkey)) {
                        let levelsForUlti = [6,12,18];
                        maxLevel = 3;
                        if (skillkey.startsWith("meepo")) {
                            levelsForUlti = [3,10,17];
                        }
                        levelForUp = levelsForUlti[current];
                    } else if (this.isSkillTalent(skillkey)) {
                        levelForUp = (current + 1) * 5 + 5;
                        maxLevel = 4;
                    } else {
                        levelForUp = current * 2 + 1;
                        maxLevel = 4;
                        if (skillkey.startsWith("invoker")) {
                            maxLevel = 7;
                        } 
                    }
                    return !(level < levelForUp || current === maxLevel);
                }

                getRandomNum (size) {
                    return Math.floor(Math.random() * size);
                }

                generateBuild () {
                    const activeHeroes = this.heroes.filter(hero => hero.isActive);
                    let randomNum = this.getRandomNum(activeHeroes.length);
                    const hero = activeHeroes[randomNum];
                    const allBootsItems = this.items.filter(item => this.isItemBoots(item.key));
                    randomNum = this.getRandomNum(allBootsItems.length);
                    const boots = allBootsItems[randomNum];
                    const otherItems = this.items
                        .filter(item => 
                            !this.isItemBoots(item.key)
                            && item.cost >= 2000
                            && ["rare","epic","artifact"].includes(item.qual)
                            && !this.ignoredItems.includes(item.key)
                        )
                        .shuffle()
                        .slice(0, 5);
                    const skills = this.generateSkillBuild(hero.key); 
                    console.log(skills);
                    return { hero, items: [ boots, ...otherItems ], skills };
                }

                generateSkillBuild (heroname) {
                    const skills = this.getHeroSkills(heroname);
                    const currentLevels = {};
                    const build = [];
                    skills.forEach(skill => currentLevels[skill.key] = 0);
                    for (let level = 1; level <= 25; level++) {
                        const skillsCanBeLearned = skills.filter(skill => {
                            let current = currentLevels[skill.key];
                            if (this.isSkillTalent(skill.key)) {
                                current = currentLevels["talent_left"] + currentLevels["talent_right"];
                            }
                            return this.canSkillBeLearned(skill.key, level, current);
                        });
                        if (skillsCanBeLearned.length) {
                            const skill = skillsCanBeLearned[this.getRandomNum(skillsCanBeLearned.length)];
                            const skillIndex = skills.findIndex(ability => ability.key === skill.key);
                            build.push(skillIndex);
                            currentLevels[skill.key]++;
                        } else {
                            build.push(-1);
                        }
                    }
                    return build;
                }

                renderBuild (build) {
                    const heroContainer = $(`<div class="hero image" title="${build.hero.dname}"></div>`).data("image", this.getHeroImage(build.hero.key));
                    const itemsContainer = $(`<div class="items"></div>`);
                    const skillBuildContainer = $(`<div class="skills"></div>`);
                    build.items.forEach(item => {
                        const itemContainer = $(`<div class="item image" title="${item.dname}"></div>`).data("image", this.getItemImage(item.key));
                        itemsContainer.append(itemContainer);
                    })
                    const heroSkills = this.getHeroSkills(build.hero.key);
                    build.skills.forEach((skillIndex, level) => {
                        const skill = heroSkills[skillIndex];
                        const levelContainer = $(`<div class="level"><span>${level + 1}</span></div>`);
                        let skillContainer;
                        if (skill) {
                            skillContainer = $(`<div class="skill image" title="${skill.dname}"></div>`).data("image", this.getSkillImage(skill.key));
                        } else {
                            skillContainer = $(`<div class="skill"></div>`);
                        }
                        levelContainer.append(skillContainer);
                        skillBuildContainer.append(levelContainer);
                    });
                    const buildContainer = $(`<div class="build"></div>`);
                    $(buildContainer).append(`<button class="remove">REMOVE</button>`);
                    $(buildContainer).append(heroContainer);
                    $(buildContainer).append(itemsContainer);
                    $(buildContainer).append(skillBuildContainer);
                    $("#build").append(buildContainer);
                }

                renderHeroes () {
                    Object.keys(HeroAttribute).forEach(attrKey => {
                        const heroesContainer = $(`<div id="${HeroAttribute[attrKey]}" class="heroes"></div>`).css({ width: `${100 / Object.keys(HeroAttribute).length}%` });
                        const toggleButton = $(`<button class="toggle" id="${attrKey}">TOGGLE ${attrKey}</button>`);
                        heroesContainer.append(toggleButton);
                        this.heroes
                            .filter(hero => hero.pa === HeroAttribute[attrKey])
                            .forEach(hero => {
                                heroesContainer.append($(`<div class="hero image" id="${hero.key}" title="${hero.dname}"></div>`).data("image", this.getHeroImage(hero.key)));
                            });
                        $("#container").append(heroesContainer);
                    });
                }
            }

            let picker = null;

            $(document).ready(() => {
                $.ajax({
                    url: "https://www.dota2.com/jsfeed/heropediadata?feeds=itemdata,abilitydata,herodata",
                    type: "GET",
                    crossDomain: true,
                    dataType: "jsonp",
                    success: (data) => {
                        $("#container").html("");
                        $("#container").append(`<button class="generate">GENERATE BUILD</button><div id="build"></div>`);
                        picker = new HeroPicker(
                            Object.keys(data.herodata)
                                .map(key => ({
                                    ...data.herodata[key],
                                    key,
                                    isActive: true
                                }))
                                .sort((a, b) => a.dname.localeCompare(b.dname)),
                            Object.keys(data.itemdata).map(key => ({
                                ...data.itemdata[key],
                                key
                            })),
                            Object.keys(data.abilitydata).map(key => ({
                                ...data.abilitydata[key],
                                key,
                                hurl: data.abilitydata[key].hurl.toLowerCase()
                            }))
                        );
                        picker.renderHeroes();
                    }
                });
            });

            $(document)
                .on("click", ".heroes .hero", function () {
                    const heroname = $(this).attr("id");
                    picker.toggleHero(heroname);
                })
                .on("click", ".toggle", function () {
                    const attribute = $(this).attr("id");
                    picker.toggleAttributeHeroes(attribute);
                })
                .on("click", ".generate", function () {
                    const build = picker.generateBuild();
                    picker.renderBuild(build);
                })
                .on("click", ".remove", function () {
                    $(this).parent().remove();
                })
                .on("keydown", "body", function (e) {
                    const key = e.which;
                    if (key === 8) {
                        picker.updateSearch("remove");
                    } else if ((key >= 65 && key <= 90) || key === 32) {
                        e.preventDefault();
                        picker.updateSearch("add", String.fromCharCode(e.which));
                    }
                }).on("mousedown", "body", function (e) {
                    picker.updateSearch("clear");
                });
                $("body").on("DOMNodeInserted", ":has(.image)", function (e) {
                    $(this).find(".image").each(function () {
                        const imageSrc = $(this).data("image");
                        if (imageSrc) {
                            $(this).addClass("loading");
                            $(`<img src="${imageSrc}">`).on("load", () => {
                                $(this).animate({ opacity: 0 }, 200, function () {
                                    $(this).css({ backgroundImage: `url(${imageSrc})` });
                                    $(this).animate({ opacity: 1 }, 200);
                                });
                                $(this).removeClass("loading");
                                $(this).removeData("image");
                            });
                        }
                    });
                });
        </script>
    </body>
</html>